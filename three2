// ページの読み込みを待つ
window.addEventListener('load', init);

function init() {

  // サイズを指定
  const width = 800;
  const height = 400;

  // レンダラーを作成
  let renderer = new THREE.WebGLRenderer({
        canvas: document.querySelector('#myCanvas')
      });

  renderer.setClearColor(new THREE.Color('grey'));//背景色の設定
  document.body.appendChild( renderer.domElement );
  renderer.setSize(width, height);

  // シーンを作成
  let scene = new THREE.Scene();

  // カメラを作成
  let camera = new THREE.PerspectiveCamera(45, width / height);
  camera.position.set(0, 0, 300);
  camera.lookAt(new THREE.Vector3(0, 0, 0));

  //ライト
  const light = new THREE.PointLight( 0xffffee );
  light.position.set( 0, 100, 180 );
  //scene.add( light );
  const light2 = new THREE.PointLight( 0xffffee );
  light2.position.set( -15, 10, -10 );
  //scene.add( light2 );

  const light3 = new THREE.DirectionalLight( 0xffffee );
  light3.position.set( 0, 0, 10 );
  scene.add( light3 );


  const envlight = new THREE.AmbientLight(0xFFFFFF, 0.7);
  scene.add(envlight);




/////////////////////////////////////////////////////////////////

  //共通def
  const NUM_POS = 3;
  const VER_RECT = NUM_POS * 4;
  const PI = Math.PI;
  const CLOSE = false;
  const OPEN = true;

  let sPos = new THREE.Vector2( 0,0 );
  let sRad = 0;

  //cylinder
  const reso = 6;
  const nEdge = 2 * reso;
  const armNode = 2 * reso;
  const jointNode = armNode;
  const numFing = 4;
  const wScale = 140;
  //const handNode = armNode/2;

  //Color
  const skinCol = new THREE.Color(0xe0a080);
  const hairCol = new THREE.Color(0x5e270e);
  const eyeCol = new THREE.Color(0x30180f);
  const highCol = new THREE.Color(0xffffff);

  //material
  const hairMat = new THREE.MeshPhongMaterial({
    color: 0x994466,
    side:THREE.DoubleSide
  });


  let cUniforms =
    THREE.UniformsUtils.merge( [
      THREE.UniformsLib['lights'],
      {
        'uColor': { value: null }
      },
    ] );

  let cMat = new THREE.ShaderMaterial({
    side:THREE.DoubleSide,
    uniforms: cUniforms,
    vertexShader: document.getElementById('vs2').textContent,
    fragmentShader: document.getElementById('fs2').textContent,
    lights: true
  });

  //length
  const armLength = 20;
  const armThick = 5; //p

  //Objects
  let objArmUprL;
  let geoArmUprL;
  let objArmJntL;
  let geoArmJntL;
  let objArmLwrL;
  let geoArmLwrL;

  let objHead;

  //arm_thick
  let arm1Thick = new Array(armNode);
  for(let i=0; i<armNode; i++){
      arm1Thick[i] = armThick;
  }

  //groups
  let handG = new THREE.Group();
  let armlG = new THREE.Group();
  let armG = new THREE.Group();
  let headG = new THREE.Group();


  ///////////////////////////////////////inits
  //arm_init( 0.5, 0.2, 7*PI/8, 0 );

  headInit();
  render();
  //render();

  //renderer.render(scene, camera);

  //render();

  let count = 0;
  let angle = 0;
  let bend = 0;
  function animate(){
        count += 1;
        if(count%100==0){
          angle = count*PI/64;
        }
        //arm_update( 0.5, 0.2, PI/32, PI/64);
        //requestAnimationFrame( animate );
        //renderer.render( scene, camera );
  }
  //animate();



  function render(){
      requestAnimationFrame(render);
      renderer.render(scene, camera);
  }

  function headInit(){


    makeS();
    makeHead();
    makeEye();
    makeEar();
    //headG.rotation.y = PI/4;

    //makeLines();
    //makeEar();

    //hair_init();

    //headG.rotation.y = -PI/8;


  }


///////////////////////////////////////////////////////////////







function makeS(){

  let geometry = new THREE.SphereGeometry( 50, 32, 32 );
  const mat = new THREE.MeshPhongMaterial({
    color: 0x994466,
    //side:THREE.DoubleSide
  });

  let sphere = new THREE.Mesh( geometry, mat );
  scene.add( sphere );
  sphere.position.x = 150;
  sphere.position.z = 0;

}



function makeHead(){
  //const
  const edge = reso * 3;
  const node = reso * 3;

  //material
  const loader = new THREE.TextureLoader();// テクスチャローダーを作成
  const texture = loader.load('img/hair.png');// テクスチャ読み込み

  let uniforms =
    THREE.UniformsUtils.merge( [
      THREE.UniformsLib['lights'],
      //THREE.UniformsLib['ambient'],
      {
        'uTexure': { value: null },
        'uColor1': { value: skinCol },
        'uColor2': { value: hairCol }
      },
    ] );
  uniforms.uTexure.value = texture;

  let shdrMat = new THREE.ShaderMaterial({
    side:THREE.DoubleSide,
    uniforms: uniforms,
    vertexShader: document.getElementById('vs').textContent,
    fragmentShader: document.getElementById('fs').textContent,
    lights: true
  });

  //geometry
  let pt = [];
  const m = edge/2.0;
  for(let i=0; i<node; i++){
    let ndiv = 1 - i*1.0/(node-1);
    pt[i] = [];
    for(let j=0; j<edge; j++){
      let ediv = ( (2*m-j) - 2*(m-(j%m) ) ) / m;
      pt[i][j] = headPtCal(ndiv, ediv);
    }
    pt[i][edge] = headPtCal(ndiv, 0);
  }
  let geo = makeGeometry(node, edge+1, pt);


  //uvmap
  let uvmap = [];
  for(let i=0; i<node; i++){
    uvmap[i] = [];
    let y = i*1.0/node;
    for(let j=0; j<edge+1; j++){
      let x = 1.0 - (j*1.0/edge);
      uvmap[i][j] = [x, y];
    }
  }
  let uvs = setUvs(node, edge+1, uvmap);
  geo.addAttribute('uv', new THREE.BufferAttribute(uvs, 2) );

  //scene_add
  let geo_merg = new THREE.Geometry().fromBufferGeometry( geo );
  geo_merg.mergeVertices();
  geo_merg.computeVertexNormals(true);

  let obj = new THREE.Mesh(geo_merg, shdrMat);
  headG.add(obj);
  scene.add(headG);


}




function makeEye(){

  const node = reso;
  const edge = 3 * reso;
  const size = wScale/5.8;

  //material
  const loader = new THREE.TextureLoader();// テクスチャローダーを作成
  const texture = loader.load('img/eye.png');// テクスチャ読み込み

  let uniforms =
    THREE.UniformsUtils.merge( [
      THREE.UniformsLib['lights'],
      //THREE.UniformsLib['ambient'],
      {
        'uTexure': { value: null },
        'uColor1': { value: highCol },
        'uColor2': { value: eyeCol }
      },
    ] );
  uniforms.uTexure.value = texture;

  let shdrMat = new THREE.ShaderMaterial({
    //side:THREE.DoubleSide,
    uniforms: uniforms,
    vertexShader: document.getElementById('vs').textContent,
    fragmentShader: document.getElementById('fs').textContent,
    lights: true
  });

  //geometry
  let pt = [];
  let z = 0;
  for(let i=0;i<node;i++){
    pt[i] = [];
    let r = (node-1-i) * size / node;
    let thick = Math.pow((node-i)*1.0/node, 4) * 8; //ruco_size
    z += thick;
    for(let j=0;j<edge;j++){
      let x = r * Math.cos( j*2*PI/(edge-1) );
      let y = r * Math.sin( j*2*PI/(edge-1) );
      if(i==0){z = thick - Math.abs( r/8 * Math.cos( j*2*PI/(edge-1) ) );}
      pt[i][j] = [x,y,z];
    }
  }
  let geo = makeGeometry(node, edge, pt);

  //uvmap
  let uvmap = [];
  for(let i=0; i<node; i++){
    uvmap[i] = [];
    let y = 1.0 - (i*1.0/node);
    for(let j=0; j<edge; j++){
      let x = 1.0 - (j*1.0/edge);
      uvmap[i][j] = [x, y];
    }
  }
  let uvs = setUvs(node, edge, uvmap);
  geo.addAttribute('uv', new THREE.BufferAttribute(uvs, 2) );

  let geo_merg = new THREE.Geometry().fromBufferGeometry( geo );
  geo_merg.mergeVertices();
  geo_merg.computeVertexNormals(true);

  //object
  const posL = headPtCal(0.5, 0.16);
  const posR = headPtCal(0.5, -0.16);
  let sPosL = new THREE.Vector3(posL[0], posL[1], posL[2]);
  let sPosR = new THREE.Vector3(posR[0], posR[1], posR[2]);
  sPosL.z *= 0.91;
  sPosR.z *= 0.91;
  let objL = new THREE.Mesh(geo_merg, shdrMat);
  let objR = objL.clone();
  objL.position.set(sPosL.x, sPosL.y, sPosL.z);
  objL.rotation.x = -PI/12;
  objL.rotation.y = PI/12;
  objR.position.set(sPosR.x, sPosR.y, sPosR.z);
  objR.rotation.x = -PI/12;
  objR.rotation.y = -PI/12;
  headG.add(objL);
  headG.add(objR);
}


function makeEar(){

  const edge = nEdge;
  const node = 6;

  //radius
  const s = wScale/2;
  cUniforms.uColor.value = new THREE.Color(0xff0000);

  const mat = new THREE.MeshPhongMaterial({
    color: 0xee4466,
    side:THREE.DoubleSide
  });

  let w1 = new Array(node);
  let w2 = new Array(node);
  for(let i=0; i<node; i++){
    let t = i * 1.0/(node-1);
    w1[i] = s * Math.cos(t*PI/2);
    w2[i] = w1[i]/3;
  }

  const ep = new THREE.Vector2( s,0 );
  const cp = new THREE.Vector2( s,0 );

  let pt = makeCylinder(OPEN, node, ep, cp, w1, w2);
  let geo = makeGeometry(node, edge, pt);
  let obj = new THREE.Mesh(geo, cMat);

  let pos = headPtCal(0.5, 0.5);

  obj.rotation.y = PI/2;
  obj.position.set(pos[0],pos[1],pos[2]);
  headG.add(obj);


}


  function hair_init(){

    const edge = 12;
    const node = 12;
    let w1 = new Array(node);
    let w2 = new Array(node);

    //前髪1（下がり）
    let x = 0.2;
    let y = 0.06;
    let s = wScale/16;
    for(let i=0; i<node; i++){
      let t = i * 1.0/(node-1);
      w1[i] = s * Math.cos(Math.pow(t,1.4)*(PI/2*0.95));
      w2[i] = s*0.6 * Math.cos(Math.pow(t,1.5)*(PI/2*0.95));
    }
    let h = wScale/3.5;
    let ep = new THREE.Vector2( h, -h/2.6 );
    let cp1 = new THREE.Vector2( h/5, h/4 );
    let cp2 = new THREE.Vector2( h*1.1, h/18 );
    let rotx = 0;
    let roty = PI/18;
    makeHair(node, edge, w1, w2, ep, cp1, cp2, x, y, rotx, roty);


    //前髪２（上がり）
    x = 0.0;
    y = 0.03;
    s = wScale/10;
    h = wScale/2.8;
    for(let i=0; i<node; i++){
      let t = i * 1.0/(node-1);
      w1[i] = s * Math.cos(Math.pow(t,1.2)*(PI/2*0.95));
      w2[i] = s*0.7 * Math.cos(Math.pow(t,0.7)*(PI/2*0.94));
    }
    ep = new THREE.Vector2( h, h/10 );
    cp1 = new THREE.Vector2( h/8, h/2.5 );
    cp2 = new THREE.Vector2( h*0.98, -h/3.2 );
    roty = PI/20;
    makeHair(node, edge, w1, w2, ep, cp1, cp2, x, y, rotx, roty);


    //前髪3（上がり）
    x = -0.35;
    y = 0.025;
    s = wScale/6.8;
    h = wScale/2.3;
    for(let i=0; i<node; i++){
      let t = i * 1.0/(node-1);
      w1[i] = s * Math.cos(Math.pow(t,1.1)*(PI/2*0.95));
      w2[i] = s*0.5 * Math.cos(Math.pow(t,0.9)*(PI/2*0.96));
    }
    ep = new THREE.Vector2( h, h/8 );
    cp1 = new THREE.Vector2( h/3, h/3 );
    cp2 = new THREE.Vector2( h*0.65, -h/6 );
    roty = PI/60;
    makeHair(node, edge, w1, w2, ep, cp1, cp2, x, y, rotx, roty);


    //前髪4（上がり）
    x = -0.5;
    y = 0.025;
    s = wScale/6.5;
    h = wScale/2.3;
    for(let i=0; i<node; i++){
      let t = i * 1.0/(node-1);
      w1[i] = s * Math.cos(Math.pow(t,1.1)*(PI/2*0.96));
      w2[i] = s*0.5 * Math.cos(Math.pow(t,0.9)*(PI/2*0.96));
    }
    ep = new THREE.Vector2( h, h/8 );
    cp1 = new THREE.Vector2( h/3, h/3 );
    cp2 = new THREE.Vector2( h*0.65, -h/6 );
    roty = -PI/10;
    makeHair(node, edge, w1, w2, ep, cp1, cp2, x, y, rotx, roty);


  }


  function makeHair(node, edge, w1, w2, ep, cp1, cp2, x, y, rx, ry){

    const center = new THREE.Vector2( 0,0 );
    let rot = 0;
    let pt = [];
    let zpos = new THREE.Vector2( 0,0 );

    //cal step
    let curve = new THREE.CubicBezierCurve(center,cp1,cp2,ep);
    let points = curve.getPoints( node );

    for(let i=0; i<node; i++){
      pt[i] = [];
      let pos = points[i];
      let rot = Math.atan2(pos.y-zpos.y, pos.x-zpos.x);
      for(let j=0; j<edge; j++){
        let z = w1[i] * Math.cos(j*2*PI/edge);
        let v = new THREE.Vector2(0, w2[i] * Math.sin(j*2*PI/edge));
        v = v.rotateAround(center, rot);
        pt[i][j] = [pos.x+v.x, pos.y+v.y, z];
      }
      zpos = pos;
    }

    let geo = makeGeometry(node, edge, pt);
    let obj = new THREE.Mesh(geo, hairMat);
    let sPos = headPtCal(y, x);
    obj.position.set(sPos[0], sPos[1]*0.85, sPos[2]*0.9);
    obj.rotation.x = rx;
    obj.rotation.y = -PI/2 + ry;
    headG.add(obj);

  }



  function makeLines(){

    const mat = new THREE.LineBasicMaterial({color: 0x000000, linewidth: 4});

    const mo_w = 0.02;
    const mo_h = mo_w * 0.9;
    const moEdge = Math.round(wScale/5);
    let moGeoL = new THREE.Geometry();
    let moGeoR = new THREE.Geometry();
    for(let i=0;i<moEdge;i++){
      let x = mo_w * Math.cos(i * PI/(moEdge-1)) + mo_w;
      let y = mo_h * Math.sin(i * PI/(moEdge-1)) + 0.69;
      let moPt = headPtCal(y,x);
      moGeoL.vertices.push(new THREE.Vector3( moPt[0], moPt[1], moPt[2]) );
      moGeoR.vertices.push(new THREE.Vector3( -moPt[0], moPt[1], moPt[2]) );
    }
    const moObjL = new THREE.Line( moGeoL, mat );
    const moObjR = new THREE.Line( moGeoR, mat );
    headG.add( moObjL );
    headG.add( moObjR );


    /////eye_lash
    const el_r = wScale/20;
    const elPosL = headPtCal(0.36, 0.12);
    const elPosR = headPtCal(0.36, -0.22);
    const el_y = el_r * Math.sin(PI/4);
    const el_x = el_r * Math.cos(PI/4);
    let elGeoL = new THREE.Geometry();
    let elGeoR = new THREE.Geometry();

    elGeoL.vertices.push(new THREE.Vector3( elPosL[0], elPosL[1], elPosL[2]) );
    elGeoL.vertices.push(new THREE.Vector3( elPosL[0]-el_x, elPosL[1]+el_y, elPosL[2]) );
    elGeoR.vertices.push(new THREE.Vector3( elPosR[0], elPosR[1], elPosR[2]) );
    elGeoR.vertices.push(new THREE.Vector3( elPosR[0]-el_x, elPosR[1]+el_y, elPosR[2]) );

    const elObjL = new THREE.Line( elGeoL, mat );
    const elObjR = new THREE.Line( elGeoR, mat );
    headG.add( elObjL );
    headG.add( elObjR );


    ////eye_brown
    let ebPt1L = headPtCal(0.22, -0.14);
    let ebPt2L = headPtCal(0.235, -0.20);
    let ebPt1R = headPtCal(0.22, 0.14);
    let ebPt2R = headPtCal(0.235, 0.20);

    let ebGeoL = new THREE.Geometry();
    let ebGeoR = new THREE.Geometry();

    ebGeoL.vertices.push(new THREE.Vector3( ebPt1L[0], ebPt1L[1], ebPt1L[2]) );
    ebGeoL.vertices.push(new THREE.Vector3( ebPt2L[0], ebPt2L[1], ebPt2L[2]) );
    ebGeoR.vertices.push(new THREE.Vector3( ebPt1R[0], ebPt1R[1], ebPt1R[2]) );
    ebGeoR.vertices.push(new THREE.Vector3( ebPt2R[0], ebPt2R[1], ebPt2R[2]) );

    let ebObjL = new THREE.Line( ebGeoL, mat );
    let ebObjR = new THREE.Line( ebGeoR, mat );
    headG.add( ebObjL );
    headG.add( ebObjR );


  }






  function headPtCal(ndiv, ediv){
    //variables
    if(ndiv==0||ndiv==1){ediv=0;}
    const pidiv = Math.abs(ediv);
    const amp1 = 0.13;
    const amp2 = 0.1;
    const ffreq = 3.0;
    const bfreq1 = 0.4;
    const bfreq2 = 0.9;
    const fphase1 = 1.4;
    const fphase2 = -0.35;
    const bphase1 = 2.0;
    const bphase2 = -1.8;
    const c = 0.41;
    //cal step
    const cp = 0.4;
    const x1 = 3 * cp * ndiv * Math.pow((1-ndiv), 2);
    const x2 = 3 * cp * Math.pow(ndiv, 2) * (1-ndiv);
    const x3 = Math.pow(ndiv, 3);
    const step = x1 + x2 + x3;
    //params
    const amp = (1-ndiv)*amp1 + ndiv*amp2;
    const bfreq = (1-ndiv)*bfreq1 + ndiv*bfreq2;
    const fphase = (1-step)*fphase1 + step*fphase2;
    const bphase = (1-step)*bphase1 + step*bphase2;
    //synthesis
    const front = amp * Math.sin(step*ffreq*PI+fphase) + c;
    const back = amp * Math.sin(step*bfreq*PI+bphase) + c;
    const p_temp = Math.pow(pidiv,1.3);
    let p = p_temp>0.45 ? Math.pow(1.0-p_temp, 3) + p_temp : p_temp;
    let scale = p_temp>0.45
      ? 0.15 * Math.sin(1.8*(pidiv-0.5)*PI+PI/8)+1.12
      : 0.14 * Math.sin(1.8*pidiv*PI)+1.245;
    const synth = (1-p)*front + p*back;
    //set points
    const thita = step * PI;
    const phi = ediv * PI;
    const z = wScale * synth * Math.sin(thita) * Math.cos(phi) * scale;
    const x = wScale * synth * Math.sin(thita) * Math.sin(phi) * scale;
    const y = wScale * synth * Math.cos(thita);
    let pt = [x,y,z];
    return pt;
  }







//////////////////////arm


  function arm_init(v1, v2, rot1, rot2){

    const arm_mat = new THREE.MeshPhongMaterial({color: 0x008800});
    const hand_mat = new THREE.MeshPhongMaterial({color: 0x660066});
    const cp = new THREE.Vector2( 0,0 );

    //make_hand
    let node = armNode;
    let handThick = new Array(node);
    let fingThick = new Array(node);
    for(let i=0; i<node; i++){
        let t = i * 1.0/(node-1);
        handThick[i] = armThick * Math.cos(Math.pow(t,3)*Math.PI/5);
        fingThick[i] = armThick/3 * Math.cos(Math.pow(t,2)*Math.PI/2.6);
    }
    //make_palm
    const handLength = armLength/5;
    const hp = new THREE.Vector2( handLength,0 );
    let hand_pt = makeCylinder(CLOSE, node, hp, cp, handThick, handThick);
    let geoHand = makeGeometry(node+1, nEdge, hand_pt);
    let objHand = new THREE.Mesh(geoHand, hand_mat);
    handG.add(objHand);
    //make_fingers
    let objFing = new Array(numFing);
    const fp = hp.multiplyScalar(0.8);
    let fing_pt = makeCylinder(CLOSE, node, fp, cp, fingThick, fingThick);
    let geoFing = makeGeometry(node+1, nEdge, fing_pt);
    for(let i=0; i<numFing; i++){
      objFing[i] = new THREE.Mesh(geoFing, hand_mat);
      let angle = [-PI/6, -PI/18, PI/16, PI/5];
      let z = handLength/1.1 * Math.sin(angle[i]);
      let x = handLength/1.1 * Math.cos(angle[i]);
      let pos = new THREE.Vector3(x, 0, z);
      objFing[i].rotation.y = -angle[i];
      objFing[i].position.set(pos.x, pos.y, pos.z);
      handG.add(objFing[i]);
    }

    //mapping
    const bend1 = mapping(v1, -1.0, 2.0, PI/4, -PI/2);
    const bend2 = mapping(v2, 0.0, 1.5, 0.0, -3*PI/4);
    let {ep1, cp1, ep2, cp2} = getBezierpt(bend1, bend2);
    //upper_arm
    let armu_pt = makeCylinder(OPEN, node, ep1, cp1, arm1Thick, arm1Thick);
    geoArmUprL = makeGeometry(node, nEdge, armu_pt);
    objArmUprL = new THREE.Mesh(geoArmUprL, arm_mat);
    //joint
    sPos = ep1.multiplyScalar(0.99);
    let armj_pt = makeJoint(armThick, bend2);
    geoArmJntL = makeGeometry(jointNode, nEdge, armj_pt);
    objArmJntL = new THREE.Mesh(geoArmJntL, arm_mat);
    //lower_arm
    let arml_pt = makeCylinder(OPEN, node, ep2, cp2, arm1Thick, arm1Thick);
    geoArmLwrL = makeGeometry(node, nEdge, arml_pt);
    objArmLwrL = new THREE.Mesh(geoArmLwrL, arm_mat);
    //hand_pos
    sPos.add(ep2);
    handG.position.set(sPos.x, sPos.y, 0);
    handG.rotation.z = sRad;
    //Grouping
    armlG.add(objArmJntL);
    armlG.add(objArmLwrL);
    armlG.add(handG);
    armG.add(objArmUprL);
    armG.add(armlG);
    //rotation
    let axis = new THREE.Vector3(Math.cos(bend1),Math.sin(bend1),0).normalize();
    let angle = rot2;
    let q = new THREE.Quaternion();
    q.setFromAxisAngle(axis,angle);
    armlG.applyQuaternion(q);
    armG.rotation.x = rot1;

    scene.add(armG);
  }



  function arm_update(v1, v2, rot1, rot2){

    sRad = 0;
    sPos = new THREE.Vector2( 0,0 );

    const bend1 = mapping(v1, -1.0, 2.0, PI/4, -PI/2);
    const bend2 = mapping(v2, 0.0, 1.5, 0.0, -3*PI/4);
    let {ep1, cp1, ep2, cp2} = getBezierpt(bend1, bend2);

    let node = armNode;
    //arm_geoUpdate
    let armu_pt = makeCylinder(OPEN, node, ep1, cp1, arm1Thick, arm1Thick);
    updateGeometry(node, nEdge, armu_pt, geoArmUprL);
    sPos = ep1.multiplyScalar(0.99);
    let armj_pt = makeJoint(armThick, bend2);
    updateGeometry(jointNode, nEdge, armj_pt, geoArmJntL);
    let arml_pt = makeCylinder(OPEN, node, ep2, cp2, arm1Thick, arm1Thick);
    updateGeometry(node, nEdge, arml_pt, geoArmLwrL);
    ///hand_geoUpdate
    sPos.add(ep2);
    handG.position.set(sPos.x, sPos.y, 0);
    handG.rotation.z = sRad;

    //rotation
    let axis1 = new THREE.Vector3(1,0,0);
    let angle1 = rot1;
    let axis2 = new THREE.Vector3(Math.cos(bend1),Math.sin(bend1),0).normalize();
    let angle2 = rot2;
    let q1 = new THREE.Quaternion();
    let q2 = new THREE.Quaternion();
    q1.setFromAxisAngle(axis1,angle1);
    q2.setFromAxisAngle(axis2,angle2);
    armlG.applyQuaternion(q2);
    armG.applyQuaternion(q1);
  }


  function getBezierpt(bend1, bend2){

    let diff = Math.abs(bend1) * -Math.PI/8;
    let rad = bend1 + bend2 + diff;
    //arm1
    let len = armLength;
    const x1 = len * Math.cos(bend1);
    const y1 = len * Math.sin(bend1);
    const ep1 = new THREE.Vector2( x1,y1 );
    let cp1 = new THREE.Vector2( 0,0 );
    ep1.y>0 ? cp1.y = y1/2 : cp1.x = -y1/2;
    //arm2
    len -= armThick*Math.abs(bend2);
    const x2 = len * Math.cos(rad);
    const y2 = len * Math.sin(rad);
    const ep2 = new THREE.Vector2( x2,y2 );
    const cp2 = new THREE.Vector2( 0,0 );

    return {ep1, cp1, ep2, cp2}
  }











////////////////////////共通関数


  function makeCylinder(open, node, ep, cp, h, w){

    const center = new THREE.Vector2( 0,0 );
    let zpos = new THREE.Vector2( 0,0 );
    let pt = [];
    let rot = 0;
    let index = open ? node : node+1;
    for(var i=0; i<index; i++){
      pt[i] = [];
      let t = i==node ? 1.0 : i * 1.0/(node-1);
      let x = (2 * cp.x * t * (1-t)) + (ep.x * Math.pow(t,2));
      let y = (2 * cp.y * t * (1-t)) + (ep.y * Math.pow(t,2));
      //rot
      if(i==0){rot=sRad;}
      else if(i==index-1){rot=Math.atan2(ep.y, ep.x);}
      else{rot = Math.atan2(y-zpos.y, x-zpos.x);}
      if(i==node){w[i]=0; h[i]=0;}
      zpos = new THREE.Vector2( x,y );
      //set points
      for(var j=0; j<nEdge; j++){
        let z = w[i] * Math.cos(j*2*Math.PI/nEdge);
        let v = new THREE.Vector2(0, h[i] * Math.sin(j*2*PI/nEdge));
        v = v.rotateAround(center, rot);
        pt[i][j] = [x+v.x+sPos.x, y+v.y+sPos.y, z];
      }
    }
    sRad = rot;
    return pt;
  }


  function makeJoint(thick, rad){

    let pt = [];
    let r = thick;
    let origin = new THREE.Vector2( 0,-r );
    origin.add(sPos);
    origin.rotateAround(sPos, sRad);

    for(let i=0; i<jointNode; i++){
      pt[i] = [];
      let t = i * rad/(jointNode-1) + sRad;
      let center = new THREE.Vector2( 0,r );
      center.add(origin);
      center.rotateAround(origin, t);
      for(let j=0; j<nEdge; j++){
        let z = r * Math.cos(j*2*PI/nEdge);
        let v = new THREE.Vector2(0, r * Math.sin(j*2*PI/nEdge));
        v.add(center);
        v.rotateAround(center, t);
        pt[i][j] = [v.x, v.y, z];
      }
    }
    //update values
    sRad += rad;
    sPos = new THREE.Vector2(0,r).add(origin).rotateAround(origin, sRad);
    return pt;
}

  //マッピング
  function mapping(value, inMin, inMax, outMin, outMax){
    let norm = (value - inMin)/(inMax - inMin);
    let out = norm * (outMax - outMin) + outMin;
    return out;
  }


  function updateGeometry(nNode, nEdge, pt, geometry){
    geometry.attributes.position.needsUpdate = true;
    let vertices = setVertices(nNode, nEdge, pt);
    geometry.attributes.position.array = vertices;
  }


  function makeGeometry(nNode, nEdge, pt){

    const vertices = setVertices(nNode, nEdge, pt);
    const indices = setIndices(nNode, nEdge);
    let geometry = new THREE.BufferGeometry();
    geometry.addAttribute('position', new THREE.BufferAttribute(vertices, NUM_POS));
    geometry.setIndex(new THREE.BufferAttribute(indices, 1));
    geometry.computeVertexNormals();
    return geometry;
  }



  function setUvs(nNode, nEdge, pt){
    const nPos = 2;
    const nVert = nPos * 4;
    const numVertices = nVert*(nNode-1)*nEdge;
    let vertices = new Float32Array(numVertices);
    for(let i=0; i<nNode-1; i++){
      for(let j=0; j<nEdge; j++){
        for(let k=0;k<nPos;k++){
          let n = i*nVert*nEdge + j*nVert + k;
          vertices[n+nPos*0] = pt[i][j][k];
          vertices[n+nPos*1] = pt[i][(j+1)%nEdge][k];
          vertices[n+nPos*2] = pt[i+1][(j+1)%nEdge][k];
          vertices[n+nPos*3] = pt[i+1][j][k];
        }
      }
    }
    return vertices;
  }


  function setVertices(nNode, nEdge, pt){
    let numVertices = VER_RECT*(nNode-1)*nEdge;
    let vertices = new Float32Array(numVertices);
    for(var i=0; i<nNode-1; i++){
      for(var j=0; j<nEdge; j++){
        for(var k=0;k<NUM_POS;k++){
          let n = i*VER_RECT*nEdge + j*VER_RECT + k;
          vertices[n+NUM_POS*0] = pt[i][j][k];
          vertices[n+NUM_POS*1] = pt[i][(j+1)%nEdge][k];
          vertices[n+NUM_POS*2] = pt[i+1][(j+1)%nEdge][k];
          vertices[n+NUM_POS*3] = pt[i+1][j][k];
        }
      }
    }
    return vertices;
  }


  function setIndices(nNode, nEdge){
    let numIndices = (VER_RECT*(nNode-1)*nEdge)/2;
    let order = [0,1,2,2,3,0];
    let indices = new Uint16Array(numIndices);
    for(let i=0; i<numIndices/6; i++){
      for(let j=0; j<order.length; j++){
        indices[i*6+j] = i*4+order[j];
      }
    }
    return indices;
  }






}
