// ページの読み込みを待つ
window.addEventListener('load', init);

function init() {

  // サイズを指定
  const width = 800;
  const height = 400;

  // レンダラーを作成
  let renderer = new THREE.WebGLRenderer({
        canvas: document.querySelector('#myCanvas')
      });

  renderer.setClearColor(new THREE.Color('grey'));//背景色の設定
  document.body.appendChild( renderer.domElement );
  renderer.setSize(width, height);

  // シーンを作成
  let scene = new THREE.Scene();

  // カメラを作成
  let camera = new THREE.PerspectiveCamera(45, width / height);
  camera.position.set(0, 0, 80);
  camera.lookAt(new THREE.Vector3(0, 0, 0));

  //ライト
  const directionalLight = new THREE.DirectionalLight(0xffffff,0.2);
  directionalLight.position.set(0,1,10);
  scene.add(directionalLight);

  const envlight = new THREE.AmbientLight(0xFFFFFF, 0.4);
  scene.add(envlight);

  //animation


/////////////////////////////////////////////////////////////////

  //共通def
  const NUM_POS = 3;
  const VER_RECT = NUM_POS * 4;
  const PI = Math.PI;
  const CLOSE = false;
  const OPEN = true;


  //cylinder
  const armNode = 6;
  //const handNode = armNode/2;
  const jointNode = 6;
  const nEdge = 10;

  let endAngle = 0;
  const armLength = 20;
  const armThick = 5; //p

  let armBend1 = 0;
  let armBend2 = 0;
  let armRot1 = 0;
  let armRot2 = 0;

  let arm1Obj;
  let arm1Geo;
  let armjObj;
  let armjGeo;
  let arm2Obj;
  let arm2Geo;

  let jPos;

  //thick
  let arm1Thick = new Array(armNode);
  for(let i=0; i<armNode; i++){
      arm1Thick[i] = armThick;
  }



  //let armG1 = new THREE.Group();

  arm_init( 1,1 );

  renderer.render(scene, camera);

  let count = 0;
  function animate(){
        count += 0.01;
        if(count>1){
          count = 0;
        }
        arm_update( count, count );
        console.log(count);
        requestAnimationFrame( animate );
        renderer.render( scene, camera );
  }
  //animate();





  function arm_init(v1, v2){

    const arm_mat = new THREE.MeshPhongMaterial({color: 0x008800});
    const hand_mat = new THREE.MeshPhongMaterial({color: 0x660066});
    let {ep1, cp1, ep2, cp2} = getBezierpt(v1, v2);
    let node = armNode;

    let arm1_pt = makeCylinder(true, node, ep1, cp1, arm1Thick, arm1Thick);
    arm1Geo = makeGeometry(node, nEdge, arm1_pt);
    arm1Obj = new THREE.Mesh(arm1Geo, arm_mat);

    let armj_pt = makeJoint(armThick);
    armjGeo = makeGeometry(jointNode, nEdge, armj_pt);
    armjObj = new THREE.Mesh(armjGeo, hand_mat);
    ep1.multiplyScalar(0.99);
    armjObj.position.set(ep1.x, ep1.y, 0);

    let arm2_pt = makeCylinder(true, node, ep2, cp2, arm1Thick, arm1Thick);
    arm2Geo = makeGeometry(node, nEdge, arm2_pt);
    arm2Obj = new THREE.Mesh(arm2Geo, arm_mat);
    //let jOrigin =
    //jPos = new THREE.Vector2(0,0).add(ep1).rotateAround(ep1, armBend1+armBend2);
    //console.log(armBend2);
    //arm2Obj.position.set(jPos.x, jPos.y, 0);

    scene.add(arm1Obj);
    scene.add(armjObj);
    scene.add(arm2Obj);

  }

  function arm_update(v1, v2){

    endAngle = 0;
    let node = armNode;
    let {ep1, cp1, ep2, cp2} = getBezierpt(v1, v2);
    let arm1_pt = makeCylinder(OPEN, node, ep1, cp1, arm1Thick, arm1Thick);
    updateGeometry(node, nEdge, arm1_pt, arm1Geo);
    let armj_pt = makeJoint(armThick);
    updateGeometry(jointNode, nEdge, armj_pt, armjGeo);

  }


  function getBezierpt(v1, v2){

    armBend1 = mapping(v1, -1.0, 2.0, PI/4, -PI/2);
    armBend2 = mapping(v2, 0.0, 1.5, 0.0, -3*PI/4);

    let diff = Math.abs(armBend1) * -Math.PI/8;
    let rad = armBend1 + armBend2 + diff;
    console.log(rad);

    //arm1
    let len = armLength;
    const x1 = len * Math.cos(armBend1);
    const y1 = len * Math.sin(armBend1);
    const ep1 = new THREE.Vector2( x1,y1 );
    let cp1 = new THREE.Vector2( 0,0 );
    ep1.y>0 ? cp1.y = y1/2 : cp1.x = -y1/2;
    //arm2
    const div = jointNode-1;
    const t = (PI - armBend2/div)/2;
    const sub = 2 * armThick * -Math.cos(t) * div;
    len -= sub;
    const x2 = len * Math.cos(rad);
    const y2 = len * Math.sin(rad);
    const ep2 = new THREE.Vector2( x2,y2 );
    const cp2 = new THREE.Vector2( 0,0 );

    return {ep1, cp1, ep2, cp2}
  }











////////////////////////共通関数


  function makeCylinder(open, node, ep, cp, h, w){

    const center = new THREE.Vector2( 0,0 );
    let zpos = new THREE.Vector2( 0,0 );
    let pt = [];
    let rot = 0;
    let index = open ? node : node+1; //for CLOSE
    for(var i=0; i<index; i++){
      pt[i] = [];
      let t = i * 1.0/(node-1);
      if(i==node){t=1.0;} //for CLOSE
      let x = (2 * cp.x * t * (1-t)) + (ep.x * Math.pow(t,2));
      let y = (2 * cp.y * t * (1-t)) + (ep.y * Math.pow(t,2));
      rot = Math.atan2(y-zpos.y, x-zpos.x);
      if(i==0){rot=endAngle;}
      if(i==node-1){rot=armBend1;}
      zpos = new THREE.Vector2( x,y );
      //set points
      for(var j=0; j<nEdge; j++){
        let z = w[i] * Math.cos(j*2*Math.PI/nEdge);
        let v = new THREE.Vector2(0, h[i] * Math.sin(j*2*PI/nEdge));
        v = v.rotateAround(center, rot);
        pt[i][j] = [v.x+x, v.y+y, z];
      }
    }
    endAngle = rot;
    return pt;
  }


  function makeJoint(thick){

    let pt = [];
    let r = thick;
    const pos = new THREE.Vector2( 0,0 );
    let origin = new THREE.Vector2( 0,-r );
    origin.rotateAround(pos, armBend1);

    for(let i=0; i<jointNode; i++){
      pt[i] = [];
      let t = i * armBend2/(jointNode-1) + armBend1;
      let center = new THREE.Vector2( 0,r );
      center.add(origin);
      center.rotateAround(origin, t);
      for(let j=0; j<nEdge; j++){
        let z = r * Math.cos(j*2*PI/nEdge);
        let v = new THREE.Vector2(0, r * Math.sin(j*2*PI/nEdge));
        v.add(center);
        v.rotateAround(center, t);
        pt[i][j] = [v.x, v.y, z];
      }
    }
    //update values
    endAngle += armBend2;
    return pt;
}

  //マッピング
  function mapping(value, inMin, inMax, outMin, outMax){
    let norm = (value - inMin)/(inMax - inMin);
    let out = norm * (outMax - outMin) + outMin;
    return out;
  }


  function updateGeometry(nNode, nEdge, pt, geometry){
    geometry.attributes.position.needsUpdate = true;
    let vertices = setVertices(nNode, nEdge, pt);
    geometry.attributes.position.array = vertices;
  }


  function makeGeometry(nNode, nEdge, pt){

    const vertices = setVertices(nNode, nEdge, pt);
    const indices = setIndices(nNode, nEdge);
    let geometry = new THREE.BufferGeometry();
    geometry.addAttribute('position', new THREE.BufferAttribute(vertices, NUM_POS));
    geometry.setIndex(new THREE.BufferAttribute(indices, 1));
    geometry.computeVertexNormals();
    return geometry;
  }


  function setVertices(nNode, nEdge, pt){
    let numVertices = VER_RECT*(nNode-1)*nEdge;
    let vertices = new Float32Array(numVertices);
    for(var i=0; i<nNode-1; i++){
      for(var j=0; j<nEdge; j++){
        for(var k=0;k<NUM_POS;k++){
          let n = i*VER_RECT*nEdge + j*VER_RECT + k;
          vertices[n+NUM_POS*0] = pt[i][j][k];
          vertices[n+NUM_POS*1] = pt[i][(j+1)%nEdge][k];
          vertices[n+NUM_POS*2] = pt[i+1][(j+1)%nEdge][k];
          vertices[n+NUM_POS*3] = pt[i+1][j][k];
        }
      }
    }
    return vertices;
  }


  function setIndices(nNode, nEdge){
    let numIndices = (VER_RECT*(nNode-1)*nEdge)/2;
    let order = [0,1,2,2,3,0];
    let indices = new Uint16Array(numIndices);
    for(let i=0; i<numIndices/6; i++){
      for(let j=0; j<order.length; j++){
        indices[i*6+j] = i*4+order[j];
      }
    }
    return indices;
  }






}
