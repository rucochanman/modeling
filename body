int BODY_NODE = 5;
int BODY_DIV = 8;
PVector[][] body_pt = new PVector[BODY_NODE][BODY_DIV];
PVector cp_body = new PVector(0,-45,0);

void setup(){
  size(500, 500, P3D); 
  noLoop();
}


void draw(){

  pushMatrix();
  translate(width/2,height/2);
  //rotateX(PI/2);
  strokeWeight(5);
  point(0,0,0);
  

  PVector ep_body = new PVector(10,-90,0);
  
  body_cul(ep_body);
  
  popMatrix();
}


void body_cul(PVector end){
  
  float rotX = 0;
  float rotY = 0;
  float rotZ = PI/2;
  float r = 50;
  
  for(int i=0;i<BODY_NODE;i++){
    for(int j=0;j<BODY_DIV;j++){
      
      float t = i * 1.0/(BODY_NODE-1);
      float sampx = (2 * cp_body.x * t * (1-t)) + (end.x * pow(t,2));
      float sampy = (2 * cp_body.y * t * (1-t)) + (end.y * pow(t,2)); 
      float sampz = (2 * cp_body.z * t * (1-t)) + (end.z * pow(t,2)); 
      
      rotZ = atan2(sampx,sampy) + PI/2;
      println(i + " : " + rotZ);
      println(i + " x: " + sampx + " y: " + sampy);
      //rotZ = 1.5707964;

      float plot = j * TWO_PI/BODY_DIV + rotY;
      float x = r * sin(plot)*sin(rotZ);
      float z = r * cos(plot) * cos(rotX);
      float y = (r*sin(plot)*cos(rotZ)) + (r*cos(plot)*sin(rotX));
      stroke(255,0,i*50);
      point(sampx,sampy,sampz);
      stroke(i * 20, i * 50, i * 56);
      point(x + sampx,y + sampy,z + sampz);
      body_pt[i][j] = new PVector(x + sampx,y + sampy,z + sampz);
  
    }
  }



}
