float BODY_HEIGHT = SCALE*0.4;
float BODY_WIDTH = BODY_HEIGHT*0.95;

void make_body(float lr_value, float fb_value, float tw_value){
  //value mapping
  float lr = map(lr_value, -1, 1, 3*PI/4, PI/4);
  float fb = map(fb_value, -1, 1.5, 3*PI/4, PI/8);
  float tw = map(tw_value, -1, 1, PI/2, -PI/2); 
  //calc bone
  float h = BODY_HEIGHT;
  float ep_x = h * cos(lr);
  float ep_y = -h * sin(lr) * sin(fb);  
  float ep_z = h * sin(lr) * cos(fb); 
  //face_point
  PVector hp = new PVector(ep_x, ep_y, ep_z).normalize();
  float hh = h + SCALE/2.5;
  PVector head_pos = hp.mult(hh);
  make_face(lr, fb, tw, head_pos);
  //culc points
  PVector[][] pt = new PVector[BODY_NODE][BODY_EDGE];
  for(int i=0;i<BODY_NODE;i++){
      //bone line
      float t = i * 1.0/(BODY_NODE-1);
      float sampx = ep_x * pow(t,2);
      float sampy = (-h * t * (1-t)) + (ep_y * pow(t,2)); 
      float sampz = ep_z * pow(t,2);
      PVector bone = new PVector(sampx, sampy, sampz);  
      //units
      float r = BODY_WIDTH*cos(pow(t,1.2)*PI/4);
      PVector unit = new PVector(cos(tw*t),0,sin(tw*t));
      PVector v1 = unit.cross(bone).normalize().mult(r);
      if(i==0){v1 = new PVector(0,0,-r);}
      PVector v2 = v1.cross(bone).normalize().mult(r);
      if(i==0){v2 = new PVector(-r,0,0);}
      PVector v3 = new PVector(-v1.x,-v1.y,-v1.z);
      PVector v4 = new PVector(-v2.x,-v2.y,-v2.z);   
      //set points
      int seg = BODY_EDGE/4;
      for(int j=0; j<seg; j++){ 
        float div = j * 1.0/(seg);
        pt[i][j] = PVector.lerp(v1,v2,div).normalize().mult(r).add(bone);
        pt[i][j+seg] = PVector.lerp(v2,v3,div).normalize().mult(r).add(bone);
        pt[i][j+2*seg] = PVector.lerp(v3,v4,div).normalize().mult(r).add(bone);
        pt[i][j+3*seg] = PVector.lerp(v4,v1,div).normalize().mult(r).add(bone);
      }
  }
  make_mesh(BODY_NODE, BODY_EDGE, pt);
  
  //arm_pos
  float a_h = 0.66;
  float a_r = (BODY_WIDTH*0.9)*cos(pow(a_h,1.2)*PI/4);
  float asampx = ep_x * pow(a_h,2);
  float asampy = (-h * a_h * (1-a_h)) + (ep_y * pow(a_h,2)); 
  float asampz = ep_z * pow(a_h,2);
  PVector abone = new PVector(asampx, asampy, asampz);
  PVector aunit = new PVector(cos(tw*a_h),0,sin(tw*a_h));
  PVector av1 = aunit.cross(abone).normalize().mult(a_r);  
  PVector av2 = av1.cross(abone).normalize().mult(a_r); 
  PVector av3 = new PVector(-av2.x,-av2.y,-av2.z);
  armR_pos = av2.add(abone);
  armL_pos = av3.add(abone);
  
  make_hip();
}


void make_hip(){
  int hip_node = int(BODY_NODE/2);
  int hip_edge = BODY_EDGE;
  float hip_height = BODY_HEIGHT/2;
  PVector[][] pt = new PVector[hip_node][hip_edge];   
  for(int i=0; i<hip_node;i++){ 
    float t = i * 1.0/(hip_node-1);
    float y = t*hip_height;
    for(int j=0; j<BODY_EDGE;j++){
      float r = BODY_WIDTH*cos(pow(t,1.5)*PI/2);
      float x = r * cos(j*TWO_PI/BODY_EDGE);
      float z = r * sin(j*TWO_PI/BODY_EDGE);      
      pt[i][j] = new PVector(x,y,z);
    }
  }
  fill(90,90,200);
  make_mesh(hip_node, BODY_EDGE, pt);
}
