void head_pt_set(){
  //head_pt
  for(int i=0; i<HEAD_EDGE; i++){  
    float m = HEAD_EDGE/2;
    float ediv = ((2*m-i)-2*(m-(i%m)))/m;
    for(int j=0; j<HEAD_NODE; j++){  
      float ndiv = j*1.0/(HEAD_NODE-1);
      head_pt[i][j] = head_pt_cal(ndiv, ediv);
    }
  }
  //eye_pt
  float z = 0;
  for(int i=0;i<EYE_NODE;i++){
    float r = (EYE_NODE-1-i) * HEAD_SIZE/5.8/EYE_NODE;
    float thick = pow((EYE_NODE-i)*1.0/EYE_NODE,4)*8;
    z += thick;
    for(int j=0;j<EYE_EDGE;j++){
      float x = r * cos(j*TWO_PI/(EYE_EDGE-1));
      float y = r * sin(j*TWO_PI/(EYE_EDGE-1));
      if(i==0){z = thick - abs(r/8*cos(j*TWO_PI/(EYE_EDGE-1)));}
      eye_pt[i][j] = new PVector(x,y,z);
    }
  }
  //eye_pos 
  eye_pos = head_pt_cal(0.5, 0.16);
  eye_pos.z = eye_pos.z * 0.91;
  //eye_lash_pos
  elL_pos = head_pt_cal(0.36,0.11);
  elR_pos = head_pt_cal(0.36,-0.22);
  //eye_brown_pos
  eb1_pos = head_pt_cal(0.20,0.14);
  eb2_pos = head_pt_cal(0.21,0.20); 
  //hilights_pos
  h1L_pos = head_pt_cal(0.43,0.15);
  h1L_pos.z *= 1.15;
  h2L_pos = head_pt_cal(0.55,0.2);
  h2L_pos.z *= 1.14;
  h1R_pos = head_pt_cal(0.43,-0.2);
  h1R_pos.z *= 1.15;
  h2R_pos = head_pt_cal(0.54,-0.135);
  h2R_pos.z *= 1.14; 
  //mouth_pos
  mo_pos = head_pt_cal(0.79,0); 
}

PVector head_pt_cal(float ndiv, float ediv){
  //variables
  if(ndiv==0||ndiv==1){ediv=0;}
  float pidiv = abs(ediv);
  float amp1 = 0.13;
  float amp2 = 0.1;  
  float ffreq = 3.0;
  float bfreq1 = 0.4;
  float bfreq2 = 0.9;
  float fphase1 = 1.4;
  float fphase2 = -0.35;
  float bphase1 = 2.0;    
  float bphase2 = -1.8;
  float c = 0.41;
  //cal step
  float cp = 0.4;
  float x1 = 3 * cp * ndiv * pow((1-ndiv),2);
  float x2 = 3 * cp * pow(ndiv,2) * (1-ndiv);
  float x3 = pow(ndiv,3);
  float step = x1 + x2 + x3;
  //params
  float famp = (1-ndiv)*amp1 + ndiv*amp2;
  float bamp = (1-ndiv)*amp1 + ndiv*amp2;
  float bfreq = (1-ndiv)*bfreq1 + ndiv*bfreq2;
  float fphase = (1-step)*fphase1 + step*fphase2; 
  float bphase = (1-step)*bphase1 + step*bphase2;
  //synthesis
  float front = famp * sin(step*ffreq*PI+fphase) + c;
  float back = bamp * sin(step*bfreq*PI+bphase) + c;
  float scale = 0.14*sin(1.8*pidiv*PI)+1.245;
  float p = pow(pidiv,1.3);
  if(p>0.45){
    p=pow(1.0-p,3)+p;
    scale = 0.15*sin(1.8*(pidiv-0.5)*PI+PI/8)+1.12;
  }
  float synth = (1-p)*front + p*back;
  //set points
  float thita = PI - step * PI;
  float phi = ediv * PI;
  float z = HEAD_SIZE * synth * sin(thita) * cos(phi) * scale;
  float x = HEAD_SIZE * synth * sin(thita) * sin(phi) * scale;
  float y = HEAD_SIZE * synth * cos(thita); 
  PVector pt = new PVector(x,y,z);
  return pt;
}














void make_face(float lr, float fb, float tw, PVector pos){
  
  pushMatrix();
  translate(pos.x, pos.y, pos.z);
  rotateZ(lr);
  rotateX(fb);
  rotateY(tw);
  println(lr); //-1.8
  println(fb); //-1.57
  println(tw); //1.25
  //head
  fill(HEAD_COL);
  head_mesh(); 
  
  //eyeL
  fill(EYE_COL);
  pushMatrix();
  translate(eye_pos.x,eye_pos.y,eye_pos.z);
  rotateX(PI/12);
  rotateY(PI/12);
  make_mesh(EYE_NODE, EYE_EDGE, eye_pt);
  popMatrix(); 
  //eyeR
  pushMatrix();
  translate(-eye_pos.x,eye_pos.y,eye_pos.z);
  rotateX(PI/12);
  rotateY(-PI/12);
  make_mesh(EYE_NODE, EYE_EDGE, eye_pt);
  popMatrix();  
  
  //eye_lashL
  stroke(LINE_COL);
  strokeWeight(el_w);
  pushMatrix();
  translate(elL_pos.x,elL_pos.y,elL_pos.z);
  line(0,0,0,el_r*cos(PI/4),el_r*sin(PI/4),0);
  point(el_r*cos(PI/4),el_r*sin(PI/4),0);
  popMatrix();  
  //eye_lashR
  pushMatrix();
  translate(elR_pos.x,elR_pos.y,elR_pos.z);
  line(0,0,0,el_r*cos(PI/4),el_r*sin(PI/4),0);
  point(el_r*cos(PI/4),el_r*sin(PI/4),0);
  popMatrix();    
  
  //eye_brownL
  strokeWeight(li_w);
  point(eb1_pos.x,eb1_pos.y,eb1_pos.z);
  point(eb2_pos.x,eb2_pos.y,eb2_pos.z);   
  line(eb1_pos.x,eb1_pos.y,eb1_pos.z,eb2_pos.x,eb2_pos.y,eb2_pos.z); 
  //eye_brownR
  point(-eb1_pos.x,eb1_pos.y,eb1_pos.z);
  point(-eb2_pos.x,eb2_pos.y,eb2_pos.z);   
  line(-eb1_pos.x,eb1_pos.y,eb1_pos.z,-eb2_pos.x,eb2_pos.y,eb2_pos.z);
  make_mouth();
  
  //hilights
  fill(255);
  noStroke();
  make_hilights(h1_r, PI/10, PI/12, h1L_pos);
  make_hilights(h1_r, PI/10, -PI/10, h1R_pos);
  make_hilights(h2_r, PI/16, PI/8, h2L_pos);
  make_hilights(h2_r, PI/20, -PI/18, h2R_pos);
  
  popMatrix();
  
}


void make_mouth(){
  float wr = mo_w;
  float hr = wr*0.9;
  PVector pt;
  int TIP_EDGE = int(HEAD_SIZE/10);  
  for(int i=0;i<TIP_EDGE;i++){
    float x = wr * cos(i * PI/(TIP_EDGE-1)) + wr;
    float y = hr * sin(i * PI/(TIP_EDGE-1))+0.7;
    pt = head_pt_cal(y,x);
    point(pt.x, pt.y, pt.z);
    point(-pt.x, pt.y, pt.z);   
  }
}


void make_hilights(float r, float xang, float yang, PVector pos){
  pushMatrix();
  translate(pos.x,pos.y,pos.z);
  rotateX(xang);
  rotateY(yang);
  int TIP_EDGE = 12;
  beginShape();
  for(int i=0;i<TIP_EDGE;i++){
    float x = r * cos(i * TWO_PI/(TIP_EDGE-1));
    float y = r * sin(i * TWO_PI/(TIP_EDGE-1));
    vertex(x,y,0);
  }
  endShape(CLOSE);
  popMatrix();
}



void head_mesh(){
  beginShape(TRIANGLE_STRIP);
  for(int i=0; i<HEAD_EDGE; i++){
    for(int j=0; j<HEAD_NODE; j++){
      if(i==HEAD_EDGE-1){
        vertex(head_pt[i][j].x,head_pt[i][j].y,head_pt[i][j].z);
        vertex(head_pt[0][j].x,head_pt[0][j].y,head_pt[0][j].z);
      }else{        
        vertex(head_pt[i][j].x,head_pt[i][j].y,head_pt[i][j].z);
        vertex(head_pt[i+1][j].x,head_pt[i+1][j].y,head_pt[i+1][j].z);
      }
    }
  }
  endShape(CLOSE);
}
