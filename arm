void arm_thick_set(){
  for(int i=0; i<ARM1_NODE; i++){
    float h = ARM1_LENGTH/2;
    float t = i * 1.0/(ARM1_NODE-1);
    thickh1[i] = h * cos(pow(t,1.3)*QUARTER_PI*0.6);
    thickw1[i] = h * cos(pow(t,1.3)*(QUARTER_PI*0.8)); 
  }
  for(int i=0; i<ARM2_NODE; i++){
    float h = thickh1[ARM1_NODE-1];
    float w = thickw1[ARM1_NODE-1];
    float t = i * 1.0/(ARM2_NODE-1);
    thickh2[i] = h * cos(pow(t,0.8)*QUARTER_PI*0.7);
    thickw2[i] = w * cos(pow(t,0.8)*(QUARTER_PI));   
  }
}



void arm_make(float value1, float value2, float segrot1, float segrot2){
  float ud1 = map(value1, -1, 2, PI/4, -PI/2);

  float l1 = ARM1_LENGTH;
  float l2 = ARM2_LENGTH;  
  PVector ep1 = new PVector(l1*cos(ud1), -l1*sin(ud1));  
  PVector cp1 = new PVector(0,0);
  if(ep1.y<0){
    cp1.y = cos(atan2(ep1.x,ep1.y))*l1/2;
  }else{
    cp1.x = cos(atan2(ep1.x,ep1.y))*l1/2;
  }  
  rotateX(segrot1);
  arm_set(ARM1_NODE, ep1, cp1, thickh1, thickw1);
  translate(ep1.x, ep1.y, ep1.z);
  rotateX(segrot2);
  float ud2 = map(value2, 0, 1, 0, -2.5*PI/4);
  PVector ep2 = new PVector(l2*cos(armrot-ud2), l2*sin(armrot-ud2)); 
  PVector cp2 = new PVector(cos(armrot)*l2/2,abs(sin(armrot)*l2/2));
  arm_set(ARM2_NODE, ep2, cp2, thickh2, thickw2);
  
  
 // PVector ep2 = new PVector(l2*cos(ud2), -l2*sin(ud2));  
 // PVector cp2 = new PVector(0,0);  


  


  /*
  fill(250,250,250,0);
  rotateX(segrot1);
  arm_set(ARM1_NODE, ep1, cp1, thickh1, thickw1);
  translate(ep1.x, ep1.y, ep1.z);
  //rotateZ(armrot);
  rotateX(segrot2);
  fill(0,0,200,90);
  point(cp2.x,cp2.y);
  arm_set(ARM2_NODE, ep2, cp2, thickh2, thickw2);
  translate(ep2.x, ep2.y, ep2.z);
  rotateZ(armrot);
  */

}

void arm_set(int node, PVector ep, PVector cp, float[] thickh, float[] thickw){
  int NODE_NUM = node;
  float rot = 0;
  PVector zpos = new PVector(0,0);
  PVector[][] pt = new PVector[NODE_NUM][ARM_EDGE];
  //bone cal
  for(int i=0; i<NODE_NUM; i++){ 
    float t = i * 1.0/(NODE_NUM-1);
    float x = (2 * cp.x * t * (1-t)) + (ep.x * pow(t,2));
    float y = (2 * cp.y * t * (1-t)) + (ep.y * pow(t,2)); 
    rot = -1 * atan2(-1*(y-zpos.y),x-zpos.x);
    if(i==0){rot=armrot;}
    zpos = new PVector(x,y);

  //tes    
  stroke(0,0,0);
  strokeWeight(5);
  point(x,y);
  
    //set points
    for(int j=0; j<ARM_EDGE; j++){
      float z = thickw[i] * cos(j * 2 * PI/ARM_EDGE);
      PVector v = new PVector(0, thickh[i] * sin(j * 2 * PI/ARM_EDGE)).rotate(rot);
      pt[i][j] = new PVector(v.x + x, v.y + y, z); 
    }
  }
  armrot = rot;
  strokeWeight(1);
  make_mesh(NODE_NUM, ARM_EDGE, pt); 
}


void hand_make(){

}
