window.addEventListener("DOMContentLoaded", init);

function init() {

  //////////////////////////////////////////////////////////////////////////////////
  //		Init
  //////////////////////////////////////////////////////////////////////////////////

  // init renderer
  var renderer	= new THREE.WebGLRenderer({
    antialias: true,
    alpha: true
  });
  renderer.setClearColor(new THREE.Color('lightgrey'), 0)
  renderer.setSize( 640, 480 );
  renderer.domElement.style.position = 'absolute'
  renderer.domElement.style.top = '0px'
  renderer.domElement.style.left = '0px'
  document.body.appendChild( renderer.domElement );

  // init scene and camera
  var scene	= new THREE.Scene();

  // Create a camera
  var camera = new THREE.Camera();
  scene.add(camera);

  //light
  const light = new THREE.DirectionalLight( 0x888888 );
  light.position.set( 0, 1, 5 );
  scene.add( light );

  //light
  const light2 = new THREE.DirectionalLight( 0x999999 );
  light2.position.set( 3, -1, 0 );
  scene.add( light2 );

  //light
  const light3 = new THREE.DirectionalLight( 0xffffff );
  light3.position.set( 0, 0, 5 );
  scene.add( light3 );

  //handle resize
  window.addEventListener('resize', function(){
    onResize()
  })

  function onResize(){
    const width = window.innerWidth;
    const height = window.innerHeight;

    // レンダラーのサイズを調整する
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(width, height);

    arToolkitSource.onResizeElement()
    arToolkitSource.copyElementSizeTo(renderer.domElement)
    if( arToolkitContext.arController !== null ){
      arToolkitSource.copyElementSizeTo(arToolkitContext.arController.canvas)
    }
  }

  ////////////////////////////////////////////////////////////////////////////////
  //          handle arToolkit
  ////////////////////////////////////////////////////////////////////////////////

  //arToolkitSource
  var arToolkitSource = new THREEx.ArToolkitSource({
    sourceType : 'webcam',
  })
  arToolkitSource.init(function onReady(){
    onResize()
  })

  //atToolkitContext
  var arToolkitContext = new THREEx.ArToolkitContext({
    cameraParametersUrl: 'camera_para.dat',
    detectionMode: 'mono',
  })
  arToolkitContext.init(function onCompleted(){
    camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
  })

  // init controls for camera
  var markerControls = new THREEx.ArMarkerControls(arToolkitContext, camera, {
    type : 'pattern',
    patternUrl : 'patt.hiro',
    changeMatrixMode: 'cameraTransformMatrix'
  })
  scene.visible = false

  //////////////////////////////////////////////////////////////////////////////////
  //		render the whole thing on the page
  //////////////////////////////////////////////////////////////////////////////////

  animate();

  function animate(){
    requestAnimationFrame( animate );
    if( arToolkitSource.ready === false ){return;}
    arToolkitContext.update( arToolkitSource.domElement );
    scene.visible = camera.visible;
    headG.rotation.y += PI/64;
    renderer.render( scene, camera );
  }

  //////////////////////////////////////////////////////////////////////////////////
  //		add an object in the scene
  //////////////////////////////////////////////////////////////////////////////////

  //common-def
  const NUM_POS = 3;
  const VER_RECT = NUM_POS * 4;
  const PI = Math.PI;
  const CLOSE = false;
  const OPEN = true;
  const LEFT = false;
  const RIGHT = true;

  //resolusion
  const reso = 6;
  const headNode = 4 * reso;
  const headEdge = 3 * reso;
  const pipeEdge = 2 * reso;
  const pipeNode = 2 * reso;
  const bodyNode = 2 * reso;
  const bodyEdge = 2 * reso; //4の倍数

  //pipedef
  let pipeRad = 0;
  let lowerPipePos = new THREE.Vector2();

  //size
  const wScale = 1;
  const armLength = wScale/9;
  const armLength2 = armLength * 1.2;
  const armThick = wScale/17;
  const footLength = wScale/11;
  const footLength2 = footLength * 1.5;
  const footThick = wScale/16;
  const headSize = wScale/1.22;
  const bodyLength = wScale/4.7;
  const bodyWidth = wScale/4.1;
  let upperArmThick = new Array(pipeNode);
  let lowerArmThick = new Array(pipeNode);
  let lowerArmWidth = new Array(pipeNode);
  let upperFootThick = new Array(pipeNode);
  let lowerFootThick = new Array(pipeNode);
  let ankleThick = new Array(pipeNode);
  let bodyWidths = new Array(bodyNode);
  let bodyThicks = new Array(bodyNode);

  //Color
  const skinCol = new THREE.Color(0xefa083);
  const hairCol = new THREE.Color(0x8b0000);
  const eyeCol = new THREE.Color(0xffd700);
  const highCol = new THREE.Color(0x38180f);
  const bodyCol = new THREE.Color(0x222222);
  const stripeCol = new THREE.Color(0xcb9b8f);

  //material
  const mono_vert = document.getElementById('vs_mono').textContent;
  const mono_frag = document.getElementById('fs_mono').textContent;
  const uv_vert = document.getElementById('vs_uv').textContent;
  const uv_frag = document.getElementById('fs_uv').textContent;
  const bi_frag = document.getElementById('fs_bi').textContent;

  let uniform = THREE.UniformsUtils.merge([
    THREE.UniformsLib['lights'],{
    'uTexture': { value: null },
    'uTone': { value: null },
    'uColor1': { value: null },
    'uColor2': { value: null }
    }
  ] );

  let material = new THREE.ShaderMaterial({
    side:THREE.DoubleSide,
    uniforms: uniform,
    vertexShader: null,
    fragmentShader: null,
    lights: true
  });

  const loader = new THREE.TextureLoader();

  let monoMat = material.clone();
  monoMat.vertexShader = mono_vert;
  monoMat.fragmentShader = mono_frag;

  let uvMat = material.clone();
  uvMat.vertexShader = uv_vert;
  uvMat.fragmentShader = bi_frag;

  let skinMat = monoMat.clone();
  skinMat.uniforms.uColor1.value = skinCol;

  let bodyMat = monoMat.clone();
  bodyMat.uniforms.uColor1.value = bodyCol;

  let hairMat = monoMat.clone();
  hairMat.uniforms.uColor1.value = hairCol;

  let eyeMat = uvMat.clone();
  const eyeTex1 = loader.load('img/eye_open.png');
  const eyeTex2 = loader.load('img/eye_close.png');
  eyeMat.uniforms.uColor1.value = highCol;
  eyeMat.uniforms.uColor2.value = eyeCol;
  eyeMat.uniforms.uTexture.value = eyeTex1;

  let headMat = uvMat.clone();
  let headTex = loader.load('img/hair.png');
  headMat.uniforms.uColor1.value = skinCol;
  headMat.uniforms.uColor2.value = hairCol;
  headMat.uniforms.uTexture.value = headTex;

  //geometry
  let upperArmGeoL;
  let upperArmGeoR;
  let elbowGeoL;
  let elbowGeoR;
  let lowerArmGeoL;
  let lowerArmGeoR;
  let bodyGeo;
  let upperFootGeoL;
  let upperFootGeoR;
  let kneeGeoL;
  let kneeGeoR;
  let ankleGeoL;
  let ankleGeoR;
  let lowerFootGeoL;
  let lowerFootGeoR;

  let eyelashObj;
  let toeObjL;
  let toeObjR;

  //groups
  let handGL = new THREE.Group();
  let handGR = new THREE.Group();
  let elbowGL = new THREE.Group();
  let elbowGR = new THREE.Group();
  let lowerArmGL = new THREE.Group();
  let lowerArmGR = new THREE.Group();
  let armGL = new THREE.Group();
  let armGR = new THREE.Group();
  let armG = new THREE.Group();
  let headG = new THREE.Group();
  let bodyG = new THREE.Group();
  let toeGL = new THREE.Group();
  let toeGR = new THREE.Group();
  let kneeGL = new THREE.Group();
  let kneeGR = new THREE.Group();
  let lowerFootGL = new THREE.Group();
  let lowerFootGR = new THREE.Group();
  let footGL = new THREE.Group();
  let footGR = new THREE.Group();
  let footG = new THREE.Group();

  scene.add(headG);
  makeHead();
  makeEye();
  makeLines();
  makeEar();
  hairInit();
  makeTatoo();


  function headInit(){

    makeHead();
    makeEye2();
    makeEar();
    makeLines();
    hairInit();
    makeTatoo();
    headG.rotation.x = PI/20;
    bodyG.add(headG);

  }



  function makeHead(){
    //defs
    const node = headNode;
    const edge = headEdge;

    //uvmap
    let uvmap = [];
    for(let i=0; i<node; i++){
      uvmap[i] = [];
      let y = 1-(i/node);
      for(let j=0; j<edge+1; j++){
        let x = 1.0 - (j/edge);
        uvmap[i][j] = [x, y];
      }
    }
    let uvs = setUvs(node, edge, uvmap);

    //geometry
    let pt = [];
    const m = edge/2.0;
    for(let i=0; i<node; i++){
      let ndiv = i/(node-1);
      pt[i] = [];
      for(let j=0; j<edge; j++){
        let ediv = ( (2*m-j) - 2*(m-(j%m) ) ) / m;
        pt[i][j] = headPtCal(ndiv, ediv);
      }
      pt[i][edge] = headPtCal(ndiv, 0);
    }
    let geo = makeGeometry(node, edge, pt);
    geo.addAttribute('uv', new THREE.BufferAttribute(uvs, 2) );
    geo = mergeGeometry(geo);

    //scene_add
    let obj = new THREE.Mesh(geo, headMat);
    headG.add(obj);
  }


  function headPtCal(ndiv, ediv){
    //variables
    if(ndiv==0||ndiv==1){ediv=0;}
    const pidiv = Math.abs(ediv);
    const amp1 = 0.13;
    const amp2 = 0.1;
    const ffreq = 3.0;
    const bfreq1 = 0.3;
    const bfreq2 = 0.85;
    const fphase1 = 1.52;
    const fphase2 = -0.35;
    const bphase1 = 2.0;
    const bphase2 = -1.8;
    const c = 0.41;
    //cal step
    const cp = 0.4;
    const x1 = 3 * cp * ndiv * Math.pow((1-ndiv), 2);
    const x2 = 3 * cp * Math.pow(ndiv, 2) * (1-ndiv);
    const x3 = Math.pow(ndiv, 3);
    const step = x1 + x2 + x3;
    //params
    const amp = (1-ndiv)*amp1 + ndiv*amp2;
    const bfreq = (1-ndiv)*bfreq1 + ndiv*bfreq2;
    const fphase = (1-step)*fphase1 + step*fphase2;
    const bphase = (1-step)*bphase1 + step*bphase2;
    //synthesis
    const front = amp * Math.sin(step*ffreq*PI+fphase) + c;
    const back = amp * Math.sin(step*bfreq*PI+bphase) + c;
    const p_temp = Math.pow(pidiv,1.3);
    let p = p_temp>0.45 ? Math.pow(1.0-p_temp, 3) + p_temp : p_temp;
    let scale = p_temp>0.45
      ? 0.18 * Math.sin(1.8*(pidiv-0.5)*PI+PI/8)+1.12
      : 0.05 * Math.sin(1.8*pidiv*PI)+1.245;
    const synth = (1-p)*front + p*back;
    //set points
    const thita = step * PI;
    const phi = ediv * PI;
    const z = headSize * synth * Math.sin(thita) * Math.cos(phi) * scale;
    const x = headSize * synth * Math.sin(thita) * Math.sin(phi) * scale;
    const y = headSize * synth * Math.cos(thita);
    let pt = [x,y,z];
    return pt;
  }


  function makeEye(){
    //vars
    const node = reso;
    const edge = 3 * reso;
    const size = headSize/6.6;
    const thick = headSize/28;
    const eye_num = 2;
    const c = headSize/108;

    //geometry
    let pt = [];
    let a = 0;
    for(let i=0;i<node;i++){
      pt[i] = [];
      let t = i / (node-2);
      let r = (1 - Math.pow(t,1.3)) * size;
      let z = Math.pow(t,0.7) * thick;
      if(i==node-1){
        z = thick;
        r = 0;
      }
      for(let j=0;j<edge+1;j++){
        let theta = j * 2 * PI / edge;
        let x = r * Math.cos( theta );
        let y = r * Math.sin( -theta );
        //base line
        if(i==0){
          let add = Math.cos( theta )>0. ? 0.1 : 1.;
          let p1 =  Math.cos( theta )>0. ? 0.1 : 1.;
          let p2 =  Math.sin( theta )>0. ? 0.5 : 1.;
          a = -Math.pow(Math.abs((add+p2) * Math.cos( theta )),p1) * c;
          //a = add;
          pt[i][j] = [x,y,a];
          //console.log(z);
        }else{
          pt[i][j] = [x,y,z+(a/1.5)];
        }
      }
    }
    let geo = makeGeometry(node, edge, pt);

    //uv
    let uvmap = [];
    for(let i=0;i<node;i++){
      uvmap[i] = [];
      for(let j=0;j<edge+1;j++){
        let x = mapping(pt[i][j][0],-size, size, 0.0, (node-1)/node);
        let y = mapping(pt[i][j][1],-size, size, 0.0, (node-1)/node);
        uvmap[i][j] = [x,y];
      }
    }
    let uvs = setUvs(node, edge, uvmap);
    geo.addAttribute('uv', new THREE.BufferAttribute(uvs, 2) );
    geo = mergeGeometry(geo);

    //position
    const lr = [-1,1];
    for(let i=0; i<eye_num; i++){
      let pos = headPtCal(0.5, 0.165*lr[i]);
      let obj = new THREE.Mesh(geo, eyeMat);
      obj.position.set(pos[0], pos[1], pos[2]*1.06);
      obj.rotation.x = -PI/9.;
      obj.rotation.y = PI/9.5*lr[i];
      headG.add(obj);
    }
  }


  function makeEar(){
    //defs
    const edge = pipeEdge;
    const node = reso;
    const s = headSize/10;
    const ear_num = 2;

    //thick
    let w1 = new Array(node);
    let w2 = new Array(node);
    for(let i=0; i<node; i++){
      let t = i / (node-1);
      w1[i] = s * Math.cos(t*PI/2);
      w2[i] = w1[i]/3;
    }

    //geometry
    const ep = new THREE.Vector2( s,0 );
    let pt = makePipe(OPEN, node, edge, ep, ep, w1, w2);
    let geo = makeGeometry(node, edge, pt);
    geo = mergeGeometry(geo);

    //position
    const lr = [1,-1];
    const roty = [0, PI];
    for(let i=0; i<ear_num; i++){
      let pos = headPtCal(0.54, 0.5*lr[i]);
      let obj = new THREE.Mesh(geo, skinMat);
      obj.position.set(pos[0]*0.97, pos[1], pos[2]);
      obj.rotation.y = roty[i];
      obj.rotation.x = -PI/14;
      headG.add(obj);
    }
  }



  function makeLines(){
    //defs
    const num = 2;
    const lr = [-1, 1];
    const line_width = wScale * 2;
    const mat = new THREE.LineBasicMaterial({
      color: 0x000000, linewidth: line_width});

    //mouth
    const mo_w = 0.02;
    const mo_h = mo_w * 0.9;
    const mo_edge = 10;
    for(let i=0; i<num; i++){
      let geo = new THREE.Geometry();
      for(let j=0;j<mo_edge;j++){
        let theta = j * PI / (mo_edge-1);
        let x = mo_w * Math.cos( theta ) + mo_w;
        let y = mo_h * Math.sin( theta ) + 0.69;
        let pt = headPtCal( y,x );
        geo.vertices.push(new THREE.Vector3( pt[0]*lr[i], pt[1], pt[2]) );
      }
      let obj = new THREE.Line( geo, mat );
      headG.add( obj );
    }

    /////eye_lash
    const len = headSize/30;
    const center = new THREE.Vector3();
    const ep = new THREE.Vector3(-len, len, 0);
    let lash_geoL = new THREE.Geometry();
    lash_geoL.vertices.push(center);
    lash_geoL.vertices.push(ep);
    let lash_objL = new THREE.Line( lash_geoL, mat );
    let lash_objR = lash_objL.clone();
    const posL = headPtCal(0.36, 0.10);
    const posR = headPtCal(0.37, -0.22);
    lash_objL.position.set(posL[0], posL[1], posL[2]);
    lash_objR.position.set(posR[0], posR[1], posR[2]);
    //group
    let lashes = new THREE.Group();
    lashes.add(lash_objL);
    lashes.add(lash_objR);
    eyelashObj = lashes;
    headG.add(lashes);

    ////eye_brown
    for(let i=0; i<num; i++){
      let pos1 = headPtCal(0.22, 0.14*lr[i]);
      let pos2 = headPtCal(0.235, 0.20*lr[i]);
      let geo = new THREE.Geometry();
      geo.vertices.push(new THREE.Vector3( pos1[0], pos1[1], pos1[2]) );
      geo.vertices.push(new THREE.Vector3( pos2[0], pos2[1], pos2[2]) );
      let obj = new THREE.Line( geo, mat );
      headG.add( obj );
    }
  }


  function makeHair(p){
    //defs
    const len = p.len * headSize/3;
    const node = reso * 2;
    const edge = reso * 2;
    const w = p.w * headSize/10;
    const t = w * 0.4 * p.t;
    const endw = PI/2 * p.endw;
    const endt = PI/2 * p.endt;

    //thick
    let width = new Array(node);
    let thick = new Array(node);
    for(let i=0; i<node; i++){
      let c = i / (node-1);
      width[i] = w * Math.cos(Math.pow(c,p.cw)*(endw));
      thick[i] = t * Math.cos(Math.pow(c,p.ct)*(endt));
    }

    //cal step
    const center = new THREE.Vector2();
    let ep = new THREE.Vector2( len*p.ep.x, len*p.ep.y);
    let cp1 = new THREE.Vector2( len*p.cp1.x, len*p.cp1.y);
    let cp2 = new THREE.Vector2( len*p.cp2.x, len*p.cp2.y);
    let curve = new THREE.CubicBezierCurve(center, cp1, cp2, ep);
    let bone = curve.getPoints( node-1 );

    //set points
    let zpos = new THREE.Vector2();
    let rot = 0;
    let pt = [];
    for(var i=0; i<node; i++){
      pt[i] = [];
      let diff = new THREE.Vector2();
      diff.subVectors(bone[i], zpos);
      rot = Math.atan2(diff.y, diff.x);
      for(var j=0; j<edge; j++){
        let theta = j * 2 * PI / edge;
        let w = width[i] * Math.cos( theta );
        let h = thick[i] * Math.sin( theta )
        let v = new THREE.Vector2(0, h);
        v.add(bone[i]);
        v.rotateAround(bone[i], rot);
        pt[i][j] = [v.x, v.y, w];
      }
      zpos = bone[i];
    }

    let geo = makeGeometry(node, edge, pt);
    let geo_merg = mergeGeometry(geo);

    let obj = new THREE.Mesh(geo_merg, hairMat);
    let pos = headPtCal(p.y, p.x);
    obj.position.set(pos[0], pos[1]*0.85, pos[2]*0.9);
    obj.rotation.x = p.rotx;
    obj.rotation.y = -PI/2 + p.roty;
    headG.add(obj);
  }



  function hairInit(){
    //main
    let params = {
      len: 0.7, //length
      w: 1.5, //base_width
      t: 1.3, //base_thick
      endw: 0.96, //end_radius w
      endt: 0.95, //end_radius t
      cw: 0.7, //curve intense w
      ct: 1.3, //curve intense t
      x: -0.1, //posx -1 - 1
      y: 0.03, //posy -1 - 1
      rotx: 0, //rotatex
      roty: -PI/12, //rotatey -migi
      ep: new THREE.Vector2( 1.1, 0.45 ),
      cp1: new THREE.Vector2( 0.3, 0 ),
      cp2: new THREE.Vector2( 1, 0 ),
    };
    makeHair(params);

    //side1
    params.w = 0.8;
    params.x = -0.4;
    params.y = 0.06;
    params.ep.x = 0.9;
    params.ep.y = 0.3;
    params.cp2.x = 0.8;
    params.cp1.x = 0.6;
    params.roty = -PI/32;
    params.rotx = -PI/24;
    makeHair(params);

    //side2
    params.x = 0.1;
    params.y = 0.04;
    makeHair(params);
  }


  function makeTatoo(){
    //defs
    const line_width = wScale * 2;
    const mat = new THREE.LineBasicMaterial({
      color: 0x000000, linewidth: line_width});

    let geo = new THREE.Geometry();
    let x = [-0.45, -0.448, -0.45, -0.453, -0.455, -0.457, -0.463, -0.464, -0.465, -0.466,
      -0.466, -0.467, -0.467, -0.465, -0.46, -0.45, -0.445, -0.44, -0.43, -0.43, -0.429,
      -0.428, -0.428 , -0.429, -0.43, -0.433, -0.435, -0.438, -0.445, -0.45, -0.46, -0.465,
      -0.468, -0.469, -0.47, -0.47, -0.469, -0.467, -0.463, -0.46, -0.455, -0.45, -0.445,
      -0.44, -0.437, -0.435, -0.434, -0.433, -0.433, -0.434, -0.437, -0.44, -0.445, -0.45,
      -0.455, -0.455, -0.456, -0.456, -0.454, -0.45, -0.446, -0.443, -0.442, -0.442, -0.441
    ];
    let y = [0.545, 0.556, 0.56, 0.562, 0.561, 0.561, 0.561, 0.562, 0.563, 0.565, 0.567,
      0.57, 0.575, 0.58, 0.585, 0.585, 0.584, 0.582, 0.583, 0.584, 0.588, 0.59, 0.598,
      0.6, 0.6, 0.603, 0.605, 0.605, 0.604, 0.603, 0.602, 0.603, 0.604, 0.605, 0.608,
      0.61, 0.612, 0.615, 0.618, 0.619, 0.62, 0.62, 0.618, 0.618, 0.619, 0.62, 0.622,
      0.625, 0.627, 0.629, 0.63, 0.63, 0.63, 0.632, 0.635, 0.636, 0.639, 0.642, 0.645,
      0.646, 0.646, 0.647, 0.649, 0.65, 0.652
     ];

    for(let i=0; i<x.length; i++){
      let pos = headPtCal(y[i], x[i]);
      let pt = new THREE.Vector3(pos[0]-0.0, pos[1], pos[2]);
      geo.vertices.push(pt);
    }
    let obj = new THREE.Line( geo, mat );
    headG.add(obj);

    //head
    const node = 2;
    const edge = 12;
    const size = headSize/108;
    let pt = [];
    pt[0] = [];
    pt[1] = [];
    for(let i=0; i<edge; i++){
      let theta = i*2*PI/edge;
      let x = size * Math.cos(theta);
      let y = size * 1.5 * Math.sin(-theta);
      pt[0][i] = [x,y,0];
      pt[1][i] = [0,0,0];
    }
    let head_geo = makeGeometry(node, edge, pt);
    head_geo = mergeGeometry(head_geo);
    let head_mat = new THREE.MeshPhongMaterial({color: 0x000000});
    let head_obj = new THREE.Mesh(head_geo, head_mat);
    scene.add(head_obj);
    let head_pos = headPtCal(0.355, -0.435);
    head_obj.rotation.y = -PI/2;
    head_obj.position.set(head_pos[0]-size*10,head_pos[1],head_pos[2]);
  }


  function bodyInit(){
    //defs
    const node = bodyNode;
    const edge = bodyEdge;
    const h = bodyLength;

    //thick
    for(let i=0;i<node;i++){
      let t = i/(node-1);
      bodyWidths[i] = bodyWidth * Math.cos(Math.pow(t,0.8)*PI/5);
      bodyThicks[i] = bodyWidths[i] * 0.7;
    }
    pipeRad = PI/2;
    const ep = new THREE.Vector2( 0, h );
    let pt = makePipe(OPEN, node, edge, ep, ep, bodyWidths, bodyThicks);
    bodyGeo = makeGeometry(node, edge, pt);

    //uvmap
    let uvmap = [];
    for(let i=0; i<node; i++){
      uvmap[i] = [];
      let y = i/(node-1);
      for(let j=0; j<edge+1; j++){
        let x = j/edge;
        uvmap[i][j] = [x, y];
      }
    }
    let uvs = setUvs(node, edge, uvmap);
    bodyGeo.addAttribute('uv', new THREE.BufferAttribute(uvs, 2) );
    bodyGeo = mergeGeometry(bodyGeo);
    let obj = new THREE.Mesh(bodyGeo, torsoMat);

    makeHip();

    bodyG.add(obj);
    scene.add(bodyG);
  }


  function makeHip(){
    //defs
    const node = bodyNode;
    const edge = bodyEdge;
    const h = bodyLength/1.8;
    const center = new THREE.Vector2();

    //geometry
    let pt = [];
    for(let i=0; i<node; i++){
      pt[i] = [];
      let t = i / (node-1);
      let width = bodyWidth * Math.cos( Math.pow(t,1.9) * PI/2.4);
      let thick = width * 0.7;
      let z = t * h;
      for(let j=0; j<edge; j++){
        let theta = j * 2 * PI/edge;
        let x = Math.pow(Math.cos(theta)/width,2);
        let y = Math.pow(Math.sin(theta)/thick,2);
        let r = Math.sqrt(1/(x+y));
        let v = new THREE.Vector2(1,0);
        v.rotateAround(center, -theta);
        let p = v.multiplyScalar(r);
        pt[i][j] = [p.x, p.y, z];
      }
    }
    let geo = makeGeometry(node, edge, pt);
    geo = mergeGeometry(geo);

    let obj = new THREE.Mesh( geo, bodyMat );
    bodyG.add(obj);
    obj.rotation.x = PI/2;

  }







//////////////////////////////////////////////////////////////////////////////////
//		common - functions
//////////////////////////////////////////////////////////////////////////////////

  function makePipe(open, node, edge, ep, cp, thick, width){
    //defs
    const center = new THREE.Vector2();
    let zpos = new THREE.Vector2();
    let pt = [];
    let rot = pipeRad;

    //bone
    let curve = new THREE.QuadraticBezierCurve(center,cp,ep);
    let bone = curve.getPoints( node-1 );

    //set points
    for(var i=0; i<node; i++){
      pt[i] = [];
      if(i!=0){
        let diff = new THREE.Vector2();
        diff.subVectors(bone[i], zpos);
        rot = Math.atan2(diff.y, diff.x);
      }
      for(var j=0; j<edge; j++){
        let theta = j*2*PI/edge;
        let w = width[i] * Math.cos(theta);
        let h = thick[i] * Math.sin(theta)
        let v = new THREE.Vector2(0, h);
        v.add(bone[i]);
        v.rotateAround(bone[i], rot);
        pt[i][j] = [v.x, v.y, w];
      }
      zpos = bone[i];
    }

    //closed face
    if(!open){
      pt[node] = [];
      for(var j=0; j<edge; j++){
        pt[node][j] = [bone[node-1].x, bone[node-1].y, 0];
      }
    }

    //update
    pipeRad = rot;
    return pt;
  }

  function makeJoint2(node, edge, thick, rad){
    //defs
    let origin = new THREE.Vector2( 0,-thick[0] );
    let init = new THREE.Vector2();
    origin.rotateAround(init, pipeRad);
    let center = new THREE.Vector2( 0,thick[0] );
    center.add(origin);
    center.rotateAround(origin, pipeRad);

    //set pt
    let pt = [];
    for(let i=0; i<node; i++){
      pt[i] = [];
      let r = i==0 ? 0 : rad/(node-1);
      center.rotateAround(origin, r);
      for(let j=0; j<edge; j++){
        let theta = j * 2 * PI / edge;
        let radius = Math.sin(theta)>0 ? thick[i] : thick[0];
        let w = thick[0] * Math.cos(theta);
        let h = radius * Math.sin(theta);
        let v = new THREE.Vector2(0, h);
        v.add(center);
        v.rotateAround(center, i * r + pipeRad);
        pt[i][j] = [v.x, v.y, w];
      }
    }
    //update values
    pipeRad += rad;
    lowerPipePos = center;
    return pt;
  }


  function makeJoint(node, edge, thick, rad){
    //defs
    let origin = new THREE.Vector2( 0,-thick );
    let init = new THREE.Vector2();
    origin.rotateAround(init, pipeRad);
    let center = new THREE.Vector2( 0,thick );
    center.add(origin);
    center.rotateAround(origin, pipeRad);

    //set pt
    let pt = [];
    for(let i=0; i<node; i++){
      pt[i] = [];
      let r = i==0 ? 0 : rad/(node-1);
      center.rotateAround(origin, r);
      for(let j=0; j<edge; j++){
        let theta = j * 2 * PI / edge;
        let w = thick * Math.cos(theta);
        let h = thick * Math.sin(theta);
        let v = new THREE.Vector2(0, h);
        v.add(center);
        v.rotateAround(center, i * r + pipeRad);
        pt[i][j] = [v.x, v.y, w];
      }
    }
    //update values
    pipeRad += rad;
    lowerPipePos = center;
    return pt;
  }

  function mapping(value, inMin, inMax, outMin, outMax){
    let norm = (value - inMin)/(inMax - inMin);
    let out = norm * (outMax - outMin) + outMin;
    return out;
  }

  function updateGeometry(node, edge, pt, geometry){
    let vertices = setVertices(node, edge, pt);
    let geo_new = new THREE.BufferGeometry();
    geo_new.addAttribute('position', new THREE.BufferAttribute(vertices, NUM_POS));
    let geo_merg = new THREE.Geometry().fromBufferGeometry( geo_new );
    geo_merg.mergeVertices();
    geometry.vertices = geo_merg.vertices;
    geometry.verticesNeedUpdate = true;
    geometry.elementsNeedUpdate = true;
    geometry.computeVertexNormals();
  }

  function mergeGeometry(geo){
    let geo_merg = new THREE.Geometry().fromBufferGeometry( geo );
    geo_merg.mergeVertices();
    geo_merg.computeVertexNormals();
    return geo_merg;
  }

  function makeGeometry(node, edge, pt){
    const vertices = setVertices(node, edge, pt);
    const indices = setIndices(node, edge);
    let geometry = new THREE.BufferGeometry();
    geometry.addAttribute('position', new THREE.BufferAttribute(vertices, NUM_POS));
    geometry.setIndex(new THREE.BufferAttribute(indices, 1));
    return geometry;
  }

  function setUvs(node, edge, pt){
    const nPos = 2;
    const nVert = nPos * 4;
    const numVertices = nVert*(node-1)*edge;
    let vertices = new Float32Array(numVertices);
    for(let i=0; i<node-1; i++){
      for(let j=0; j<edge; j++){
        for(let k=0;k<nPos;k++){
          let n = i*nVert*edge + j*nVert + k;
          vertices[n+nPos*0] = pt[i][j][k];
          vertices[n+nPos*1] = pt[i][j+1][k];
          vertices[n+nPos*2] = pt[i+1][j+1][k];
          vertices[n+nPos*3] = pt[i+1][j][k];
        }
      }
    }
    return vertices;
  }

  function setVertices(node, edge, pt){
    let numVertices = VER_RECT*(node-1)*edge;
    let vertices = new Float32Array(numVertices);
    for(var i=0; i<node-1; i++){
      for(var j=0; j<edge; j++){
        for(var k=0;k<NUM_POS;k++){
          let n = i*VER_RECT*edge + j*VER_RECT + k;
          vertices[n+NUM_POS*0] = pt[i][j][k];
          vertices[n+NUM_POS*1] = pt[i][(j+1)%edge][k];
          vertices[n+NUM_POS*2] = pt[i+1][(j+1)%edge][k];
          vertices[n+NUM_POS*3] = pt[i+1][j][k];
        }
      }
    }
    return vertices;
  }

  function setIndices(node, edge){
    let numIndices = (VER_RECT*(node-1)*edge)/2;
    let order = [0,3,2,2,1,0];
    let indices = new Uint16Array(numIndices);
    for(let i=0; i<numIndices/6; i++){
      for(let j=0; j<order.length; j++){
        indices[i*6+j] = i*4+order[j];
      }
    }
    return indices;
  }

}
