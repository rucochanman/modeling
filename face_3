int FACE_NODE = 18;
int FACE_EDGE = 16;
float step, x1, x2, x3;
float FACE_SIZE = 100;
PVector[][] face_pt = new PVector[FACE_EDGE][FACE_NODE];

float[] amp1 = {0.23,0.05,0.05,0.05,0.05,0.05,0.05,0.05,0.23};
float[] amp2 = {0.01,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.5};
float[] freq1 = {2.99,3.8,3.8,3.8,3.8,3.8,3.8,3.8,1.5};
float[] freq2 = {2.65,4.8,4.8,4.8,4.8,4.8,4.8,4.8,0.93};
float phase1 = 1.4;
float phase2 = 0.2;
float[] scale_x = {1,1,1,1,1,1,1,1,1}; 
float[] scale_z = {1.3,1,1,1,1,1,1,1,1.15}; 
float[] scale_y = {1,1,1,1,1,1,1,1,1}; 
float c = 0.57;



float[] f0 = {1, 1.03, 1.035, 1.03, 1.02, 0.98,
                  0.93, 0.9, 0.91, 0.98, 1.05, 1.1,
                  1.1, 1.07, 1.01, 0.94, 0.9, 0.88}; 


void setup(){
  size(500, 500, P3D);
  noLoop();
 
}

void draw(){
  
  pushMatrix();
  translate(width/2,height/2);
  //rotateX(PI/16);
  rotateY(PI/2);
  face_make();
  //face_mesh();
  popMatrix();
  
  
}  
  
void face_make(){  

  for(int i=0; i<FACE_EDGE; i++){    
    int n = 0;
    if(i>8){n = 2*(8-i);}  
    
    //cal step
    for(int j=0; j<FACE_NODE; j++){
      //if(i==0){println(j + "amp: " + amp);}          
      
      float t = j*1.0/(FACE_NODE-1);
      x1 = 3 * FACE_NODE/2 * t * pow((1-t),2);
      x2 = 3 * FACE_NODE/2 * pow(t,2) * (1-t);
      x3 = (FACE_NODE-1) * pow(t,3);
      step = x1 + x2 + x3;
      
      float amp = (((FACE_NODE-1)-step)*amp1[i+n] +step*amp2[i+n])/(FACE_NODE-1);
      float freq = (((FACE_NODE-1)-step)*freq1[i+n] + step*freq2[i+n])/(FACE_NODE-1);
      float phase = (((FACE_NODE-1)-step)*phase1 + step*phase2)/(FACE_NODE-1);          
      
      //sin waves
      float sin = amp * sin(step*freq*PI/(FACE_NODE-1)+phase) + c;
      //set points
      float thita = PI - step * PI/(FACE_NODE-1);
      float phi = i * PI/8;
      float z = FACE_SIZE * sin * sin(thita) * cos(phi) * scale_z[i+n];
      float x = FACE_SIZE * sin * sin(thita) * sin(phi) * scale_x[i+n];
      float y = FACE_SIZE * sin * cos(thita) * scale_y[i+n];

      face_pt[i][j] = new PVector(x,y,z);
      //if(i==0){println(sin);};
      
      strokeWeight(5);
      stroke(0,0,0);
      if(i==0){point(x,y,z);};
      if(i==8){point(x,y,z);};
      
      
      z = FACE_SIZE * f0[j] * sin(thita) * cos(phi);
      x = FACE_SIZE * f0[j] * sin(thita) * sin(phi);
      y = FACE_SIZE * f0[j] * cos(thita);

      stroke(255,0,0);

      if(i==0){point(x,y,z);};
      
      //face_pt[i][j] = new PVector(x,y,z);
      
    }
  }
}



void face_mesh(){
  beginShape(TRIANGLE_STRIP);
  for(int i=0; i<FACE_EDGE; i++){
    for(int j=0; j<FACE_NODE; j++){
      if(i==FACE_EDGE-1){
        vertex(face_pt[i][j].x,face_pt[i][j].y,face_pt[i][j].z);
        vertex(face_pt[0][j].x,face_pt[0][j].y,face_pt[0][j].z);
      }else{        
        vertex(face_pt[i][j].x,face_pt[i][j].y,face_pt[i][j].z);
        vertex(face_pt[i+1][j].x,face_pt[i+1][j].y,face_pt[i+1][j].z);
      }
    }
  }
  endShape(CLOSE);
}









 
      
