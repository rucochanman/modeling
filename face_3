//to main
int HEAD_NODE = 18;
int HEAD_EDGE = 14;
float HEAD_SIZE = 150;
PVector[][] head_pt = new PVector[HEAD_EDGE][HEAD_NODE];

int EYE_NODE = 5;
int EYE_EDGE = 8;
PVector[][] eye_pt = new PVector[EYE_NODE][EYE_EDGE];

void setup(){
  size(500, 500, P3D);
  noLoop();
  noStroke();
  frameRate(3);
  //head_pt_set();

 
}

void draw(){
  
  background(200);
  //lights();
  pushMatrix();
  translate(width/2,height/2);
  //rotateX(PI/2);
  rotateY(3*PI/8);
  //rotateY(frameCount * PI/8);
  stroke(0);
  strokeWeight(5);
    eye_pt_set();
    make_mesh(EYE_NODE, EYE_EDGE, eye_pt);
  //face_mesh();
  popMatrix();
  
  
}  
  
void head_pt_set(){
  //variables
  float amp1 = 0.15;
  float ampf2 = 0.1;
  float ampb2 = 1.0;
  float ffreq1 = 3.2;
  float ffreq2 = 2.6;
  float bfreq1 = 0.4;
  float bfreq2 = 1.25;
  float phase1 = 1.7;
  float fphase2 = -0.5;
  float bphase2 = -3.82;
  float c = 0.41;
  float[] scale_x = {1, 1.45, 1.4, 1.4, 1.4, 1.4, 1.4, 1}; 
  float[] scale_z = {1.42, 1.4, 1.4, 1.2, 1.2, 1.3, 1.4, 1.42};    
  for(int i=0; i<HEAD_EDGE; i++){    
    int n = 0;
    if(i>HEAD_EDGE/2){n = 2*(HEAD_EDGE/2-i);}
    float p = (i+n)*1.0/HEAD_EDGE;  
    for(int j=0; j<HEAD_NODE; j++){  
      float t = j*1.0/(HEAD_NODE-1);
      float x1 = 3 * HEAD_NODE/2.5 * t * pow((1-t),2);
      float x2 = 3 * HEAD_NODE/2.5 * pow(t,2) * (1-t);
      float x3 = (HEAD_NODE-1) * pow(t,3);
      float step = x1 + x2 + x3; 
      //params
      float ampf = (1-t)*amp1 + t*ampf2;
      float ampb = (1-t)*amp1 + t*ampb2;      
      float ffreq = (1-t)*ffreq1 + t*ffreq2;
      float bfreq = (1-t)*bfreq1 + t*bfreq2;
      float fphase = (((HEAD_NODE-1)-step)*phase1 + step*fphase2)/(HEAD_NODE-1);          
      float bphase = (((HEAD_NODE-1)-step)*phase1 + step*bphase2)/(HEAD_NODE-1);                
      //synthesis
      float front = ampf * sin(step*ffreq*PI/(HEAD_NODE-1)+fphase) + c;
      float back = ampb * sin(step*bfreq*PI/(HEAD_NODE-1)+bphase) + c;
      float synth = (1-p)*front + p*back;      
      //set points
      float thita = PI - step * PI/(HEAD_NODE-1);
      float phi = i * PI/(HEAD_EDGE/2);
      float z = HEAD_SIZE * synth * sin(thita) * cos(phi) * scale_z[i+n];
      float x = HEAD_SIZE * synth * sin(thita) * sin(phi) * scale_x[i+n];
      float y = HEAD_SIZE * synth * cos(thita);
      head_pt[i][j] = new PVector(x,y,z);
    }
  }
}


void eye_pt_set(){
  float rad = 50;
  float thick = rad/3;
  float r, h, x, y;
  float z = 0;
  
  for(int i=0;i<EYE_NODE;i++){
    r = (EYE_NODE-i)*rad/EYE_NODE;
    h = pow((EYE_NODE-i)*1.0/EYE_NODE,2)*thick;
    z += h;
    println(z);
    for(int j=0;j<EYE_EDGE;j++){
      x = r * cos(j*TWO_PI/(EYE_EDGE-1));
      y = r * sin(j*TWO_PI/(EYE_EDGE-1));
    
      eye_pt[i][j] = new PVector(x,y,z);
      point(x,y,z);
    }
  }
}




void face_mesh(){
  beginShape(TRIANGLE_STRIP);
  for(int i=0; i<HEAD_EDGE; i++){
    for(int j=0; j<HEAD_NODE; j++){
      if(i==HEAD_EDGE-1){
        vertex(head_pt[i][j].x,head_pt[i][j].y,head_pt[i][j].z);
        vertex(head_pt[0][j].x,head_pt[0][j].y,head_pt[0][j].z);
      }else{        
        vertex(head_pt[i][j].x,head_pt[i][j].y,head_pt[i][j].z);
        vertex(head_pt[i+1][j].x,head_pt[i+1][j].y,head_pt[i+1][j].z);
      }
    }
  }
  endShape(CLOSE);
}


void make_mesh(int NODE_NUM, int EDGE_NUM, PVector[][] pt){
  for(int i=0; i<EDGE_NUM; i++){
    beginShape(TRIANGLE_STRIP);
    for(int j=0; j<NODE_NUM; j++){
      vertex(pt[j][i].x,pt[j][i].y,pt[j][i].z);
      if(i==EDGE_NUM-1){
        vertex(pt[j][0].x,pt[j][0].y,pt[j][0].z);
      }else{
        vertex(pt[j][i+1].x,pt[j][i+1].y,pt[j][i+1].z);
      }
    }
    endShape();
  }
  beginShape();
  for(int i=0; i<EDGE_NUM; i++){
    vertex(pt[NODE_NUM-1][i].x,pt[NODE_NUM-1][i].y,pt[NODE_NUM-1][i].z);
  }
  endShape();
}








 
      
